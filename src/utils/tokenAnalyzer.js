// Generated by GitHub Copilot

/**
 * トークン解析モジュール
 * OpenAI APIのトークン使用量を推定するためのユーティリティ関数群
 * 
 * 【トークン計算の基本的な考え方】
 * OpenAI APIでは、テキストはトークンに分割されて処理されます。
 * トークンは単語や単語の一部、記号などを表し、実際のトークン分割は
 * BPE（Byte-Pair Encoding）と呼ばれる複雑なアルゴリズムで行われます。
 * 
 * 本モジュールでは、正確なBPEアルゴリズムの代わりに、言語別の経験則に基づく
 * 簡易計算方式を採用しています。これにより外部ライブラリへの依存なしに
 * おおよそのトークン数を見積もることができます。
 * 
 * 【精度について】
 * この実装による推定値は実際のOpenAI APIが使用するトークン数と比較して
 * 英語テキストで±20%程度、日本語テキストで±30%程度の誤差がある場合があります。
 * 特に絵文字、特殊記号、コードなどを含む場合は誤差が大きくなる傾向があります。
 * 
 * 【各言語のトークン計算方法】
 * 1. 英語: 空白で区切られた単語数の約1.3倍をトークン数と推定
 *    - 英単語は平均して1単語あたり約1.3トークンを消費する傾向があるため
 *    - 例: "Hello world" → 2単語 × 1.3 ≒ 3トークン
 * 
 * 2. 日本語: 文字数÷1.5をトークン数と推定
 *    - 日本語は文字あたりのトークン数が英語より多く、約1.5文字で1トークン程度
 *    - 例: "こんにちは世界" → 7文字 ÷ 1.5 ≒ 5トークン
 * 
 * 【メッセージ構造のトークン計算】
 * チャットAPIのリクエスト形式では以下のオーバーヘッドが発生します：
 * - リクエスト全体に3トークンのベースコスト
 * - 各メッセージに4トークンのフォーマットコスト
 * - メッセージのrole（"system"/"user"/"assistant"）のトークン
 * - メッセージのcontentのトークン
 * 
 * 【制約】
 * トークン数が制限を超える場合は、古いメッセージから削除していきますが、
 * システムメッセージ（指示）は可能な限り保持します。
 */

/**
 * 最大トークン数の制限
 * @type {number}
 */
export const MAX_TOKENS = 4096;

/**
 * コンテキストウィンドウのサイズ（メッセージ数）
 * @type {number}
 */
export const DEFAULT_CONTEXT_WINDOW_SIZE = 10;

/**
 * トークン数を概算する（英語向け）
 * 注: これは簡易的な推定であり、実際のトークン数とは異なる場合があります
 * @param {string} text テキスト
 * @returns {number} 推定トークン数
 */
function estimateEnglishTokens(text) {
  if (!text) return 0;
  // 英語では単語数の約1.3倍がトークン数の目安
  const words = text.trim().split(/\s+/);
  return Math.ceil(words.length * 1.3);
}

/**
 * トークン数を概算する（日本語向け）
 * 注: これは簡易的な推定であり、実際のトークン数とは異なる場合があります
 * @param {string} text テキスト
 * @returns {number} 推定トークン数
 */
function estimateJapaneseTokens(text) {
  if (!text) return 0;
  // 日本語はより多くのトークンを消費するため、文字数÷1.5程度を目安とする
  return Math.ceil(text.length / 1.5);
}

/**
 * テキストの言語を簡易判定する
 * @param {string} text テキスト
 * @returns {boolean} 日本語が含まれる場合はtrue
 */
function containsJapanese(text) {
  if (!text) return false;
  // 日本語の文字が含まれるかをチェック（ひらがな、カタカナ、漢字の範囲）
  return /[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/.test(text);
}

/**
 * テキストのトークン数を言語に応じて概算する
 * @param {string} text テキスト
 * @returns {number} 推定トークン数
 */
function estimateTokens(text) {
  if (!text) return 0;
  if (containsJapanese(text)) {
    return estimateJapaneseTokens(text);
  }
  return estimateEnglishTokens(text);
}

/**
 * チャットメッセージ配列のトークン数を概算する
 * @param {Array} messages メッセージ配列 [{role: string, content: string}]
 * @returns {number} 総トークン数の推定値
 */
export function estimateMessagesTokens(messages) {
  if (!messages || !Array.isArray(messages) || messages.length === 0) return 0;
  
  // ベースコスト（リクエスト自体のトークン）
  let totalTokens = 3;
  
  // 各メッセージのトークン数を合計
  messages.forEach(message => {
    if (!message || !message.content) return;
    
    // メッセージごとにロールのトークン + コンテンツのトークン + 4（フォーマットトークン）
    totalTokens += 4;
    totalTokens += estimateTokens(message.role || 'user');
    totalTokens += estimateTokens(message.content);
  });
  
  return totalTokens;
}

/**
 * トークン数の制限を超えないようにメッセージをフィルタリングする
 * @param {Array} messages メッセージ配列
 * @param {number} [maxTokens=MAX_TOKENS] 最大トークン数
 * @param {number} [contextWindowSize=DEFAULT_CONTEXT_WINDOW_SIZE] コンテキストウィンドウサイズ
 * @returns {Array} フィルタリングされたメッセージ配列
 */
export function filterMessagesForTokenLimit(messages, maxTokens = MAX_TOKENS, contextWindowSize = DEFAULT_CONTEXT_WINDOW_SIZE) {
  if (!messages || !Array.isArray(messages) || messages.length === 0) return [];
  
  // システムメッセージを検索（通常先頭にあることが多い）
  const systemMessages = messages.filter(msg => msg.role === 'system');
  
  // 最新のユーザーメッセージとアシスタントメッセージのみを取得
  const nonSystemMessages = messages.filter(msg => msg.role !== 'system');
  
  // スライディングウィンドウのサイズ制限
  const recentMessages = nonSystemMessages.length > contextWindowSize 
    ? nonSystemMessages.slice(-contextWindowSize) 
    : nonSystemMessages;
  
  // システムメッセージを先頭に、最近のメッセージを後に配置
  const filteredMessages = [...systemMessages, ...recentMessages];
  
  // トークン数をチェック
  let tokensEstimate = estimateMessagesTokens(filteredMessages);
  
  // トークン数が制限を超える場合、古いメッセージから削除
  while (tokensEstimate > maxTokens && filteredMessages.length > 1) {
    // システムメッセージは保持したいので、システムメッセージでなく、
    // かつ最も古いメッセージを削除
    const nonSystemIndex = filteredMessages.findIndex(msg => msg.role !== 'system');
    
    if (nonSystemIndex === -1) {
      // もうシステムメッセージしかない場合は最後の手段としてシステムメッセージを減らす
      filteredMessages.shift();
    } else {
      filteredMessages.splice(nonSystemIndex, 1);
    }
    
    // トークン数を再計算
    tokensEstimate = estimateMessagesTokens(filteredMessages);
  }
  
  return filteredMessages;
}