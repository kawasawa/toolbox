// Generated by GitHub Copilot

import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { CHAT_MODELS, DEFAULT_MODEL } from '@/services/openai';
import { estimateMessagesTokens, filterMessagesForTokenLimit } from '@/utils/tokenAnalyzer';
import { useLocalStorage } from '@/hooks/useLocalStorage';
import { formatDateTime } from '@/utils/dateUtils';
import {
  RECOMMENDED_STORAGE_SIZE,
  applyStorageLimits,
  calculateStorageUsage
} from '@/utils/storageUtils';

/**
 * ローカルストレージのキー定数
 * @type {string}
 */
const CHAT_HISTORY_STORAGE_KEY = 'chat_history';

/**
 * ローカルストレージに保存するメッセージの最大数
 * @type {number}
 */
const MAX_STORED_MESSAGES = 100;

/**
 * チャットAPIを呼び出してメッセージを送信する
 * @param {Array} messages メッセージの配列 [{role: string, content: string}]
 * @param {string} model 使用するモデル名
 * @param {string} apiKey OpenAI APIキー
 * @returns {Promise<Object>} APIレスポンス
 */
export async function sendChatMessage(messages, model, apiKey) {
  try {
    // APIキーのチェック
    if (!apiKey) {
      throw new Error('APIキーが設定されていません。APIキーを設定してください。');
    }

    const response = await fetch('/api/ai/chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messages,
        model,
        apiKey
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `APIリクエストに失敗しました: ${response.status}`);
    }

    return await response.json();
  } catch (error) {
    console.error('チャットAPI呼び出しエラー:', error);
    throw error;
  }
}

/**
 * APIキー管理用のフック
 * @param {string} initialApiKey 初期APIキー
 * @returns {Object} APIキー管理に関するメソッドと状態
 */
export function useApiKey(initialApiKey = '') {
  const [apiKey, setApiKeyState] = useState(initialApiKey);
  const [hasApiKey, setHasApiKey] = useState(!!initialApiKey);

  /**
   * APIキーを設定する
   * @param {string} newApiKey 新しいAPIキー
   */
  const setApiKey = useCallback((newApiKey) => {
    setApiKeyState(newApiKey);
    setHasApiKey(!!newApiKey);
  }, []);

  // 外部からAPIキーが更新された場合に状態を更新
  useEffect(() => {
    if (initialApiKey !== apiKey) {
      setApiKey(initialApiKey);
    }
  }, [initialApiKey, apiKey, setApiKey]);

  return { apiKey, hasApiKey, setApiKey };
}

/**
 * トークン計算用のフック
 * @param {Array} messages メッセージ配列
 * @returns {number} 推定トークン数
 */
export function useTokenEstimation(messages) {
  const [estimatedTokens, setEstimatedTokens] = useState(0);
  
  // messageDataを生成し、前回と比較するためのmemoization
  const messageData = useMemo(() => {
    if (messages.length > 0) {
      // メッセージ配列からroleとcontentのみを抽出
      return messages.map(({ role, content }) => ({ role, content }));
    }
    return [];
  }, [messages]);

  useEffect(() => {
    if (messageData.length > 0) {
      const tokens = estimateMessagesTokens(messageData);
      setEstimatedTokens(tokens);
    } else {
      setEstimatedTokens(0);
    }
  }, [messageData]);

  return estimatedTokens;
}

/**
 * チャット会話を管理するためのカスタムフック
 * チャットメッセージの状態管理、API通信、ローカルストレージへの保存を担当
 * 
 * @param {Object} options オプション
 * @param {string} options.chatId チャットID（将来的にはユーザーIDやルームIDを使用）
 * @param {number} options.contextWindowSize コンテキストウィンドウサイズ（送信する過去メッセージの数）
 * @param {number} options.maxTokens 最大トークン数
 * @param {string} options.apiKey OpenAI APIキー
 * @param {number} options.maxStoredMessages 保存する最大メッセージ数（デフォルトはMAX_STORED_MESSAGES）
 * @param {number} options.maxStorageSizeBytes 保存する最大データサイズ（デフォルトはRECOMMENDED_STORAGE_SIZE）
 * @returns {Object} チャット会話管理に関するメソッドと状態
 */
export function useChatConversation({ 
  contextWindowSize,
  maxTokens,
  apiKey = '',
  maxStoredMessages = MAX_STORED_MESSAGES,
  maxStorageSizeBytes = RECOMMENDED_STORAGE_SIZE
} = {}) {
  // チャットメッセージと読み込み中の状態
  const [messages, setMessages] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedModel, setSelectedModel] = useState(DEFAULT_MODEL);
  
  // ストレージ情報の状態（初期値を設定して必ず表示されるようにする）
  const [storageInfo, setStorageInfo] = useState({
    used: 0,
    percentage: 0.0, 
    limitApplied: false,
    limitInfo: null,
    isNearLimit: false
  });
  
  // 制限情報の参照を保持するためのref
  const limitInfoRef = useRef({
    limitApplied: false,
    limitInfo: null
  });
  
  // 初期化済みフラグ - ローカルストレージからの読み込みを1回だけ行うため
  const isInitializedRef = useRef(false);
  
  // 前回のメッセージを保存するためのref - 不要な保存処理を防ぐため
  const previousMessagesRef = useRef([]);
  
  // 関連フックの統合
  const { apiKey: currentApiKey, hasApiKey, setApiKey } = useApiKey(apiKey);
  const estimatedTokens = useTokenEstimation(messages);
  const storageKey = CHAT_HISTORY_STORAGE_KEY;
  
  // 汎用フックを使用してローカルストレージ操作を行う
  const [storedMessages, setStoredMessages, removeStoredMessages] = useLocalStorage(storageKey, []);

  /**
   * ストレージ情報を更新する関数
   * 現在のストレージ使用状況を計算し、状態を更新する
   * 依存配列から storageInfo を除去して無限ループを防止
   */
  const updateStorageInfo = useCallback(() => {
    try {
      // ストレージの使用状況を計算
      const usage = calculateStorageUsage(storageKey);
      
      // 新しいストレージ情報オブジェクト
      const updatedInfo = {
        used: usage.usedBytes,
        percentage: parseFloat(usage.percentage.toFixed(2)),
        isNearLimit: usage.isNearLimit,
        // refから制限情報を取得
        limitApplied: limitInfoRef.current.limitApplied,
        limitInfo: limitInfoRef.current.limitInfo
      };
      
      // 状態を更新
      setStorageInfo(updatedInfo);
      
      // 使用量が制限に近い場合は警告
      if (usage.isNearLimit) {
        console.warn(`ローカルストレージの使用量が高くなっています: ${updatedInfo.percentage}%`);
      }
    } catch (error) {
      console.error('ストレージ情報取得エラー:', error);
    }
  }, [storageKey]); // storageInfo を依存配列から削除

  /**
   * コンポーネントのマウント時に一度だけ実行するストレージ情報の初期化
   */
  useEffect(() => {
    // コンポーネントマウント時に一度だけ実行
    updateStorageInfo();
  }, []); // 空の依存配列で初回レンダリング時のみ実行

  /**
   * ローカルストレージの使用状況を監視・更新する
   * messagesの変更時に実行される
   */
  useEffect(() => {
    // すでに初期化が完了している場合のみ実行（初回レンダリング時は実行しない）
    if (isInitializedRef.current) {
      updateStorageInfo();
    }
  }, [messages, updateStorageInfo]);

  /**
   * 初期化時のみ保存されたメッセージを読み込む
   * コンポーネントマウント時に一度だけ実行
   */
  useEffect(() => {
    // まだ初期化されておらず、ストレージにメッセージがある場合
    if (!isInitializedRef.current && Array.isArray(storedMessages) && storedMessages.length > 0) {
      console.log('[ChatConversation] ローカルストレージからメッセージを読み込みました', storedMessages.length);
      setMessages(storedMessages);
      previousMessagesRef.current = [...storedMessages];
      
      // 明示的にストレージ情報を更新し、結果に関わらず初期化完了とする
      updateStorageInfo();
      isInitializedRef.current = true;
    } else if (!isInitializedRef.current) {
      // 初期化が完了していないが、ストレージにメッセージがない場合も初期化完了とする
      console.log('[ChatConversation] 保存されたメッセージはありません');
      
      // ストレージ情報の初期化
      updateStorageInfo();
      isInitializedRef.current = true;
    }
  }, [storedMessages, updateStorageInfo]);

  /**
   * メッセージの変更を検知してローカルストレージに保存
   * メッセージが変更された場合のみ実行される
   */
  useEffect(() => {
    // 初期化完了後のみ保存処理を実行
    if (isInitializedRef.current) {
      // メッセージに変更があった場合のみ保存（JSON文字列で比較）
      const currentMessagesJSON = JSON.stringify(messages);
      const previousMessagesJSON = JSON.stringify(previousMessagesRef.current);
      
      if (currentMessagesJSON !== previousMessagesJSON) {
        console.log('[ChatConversation] メッセージが変更されたため保存します', messages.length);
        
        // メッセージ数とサイズの両方の制限を適用
        const { messages: limitedMessages, limitInfo } = applyStorageLimits(
          messages, 
          maxStoredMessages, 
          maxStorageSizeBytes
        );
        
        // 制限が適用された場合、ログと状態を更新
        if (limitInfo.countLimited || limitInfo.sizeLimited) {
          console.log(
            `[ChatConversation] 保存制限を適用しました: ${limitInfo.originalCount}件から${limitInfo.resultCount}件に制限 ` +
            `(メッセージ数制限: ${limitInfo.countLimited ? '適用' : '未適用'}, サイズ制限: ${limitInfo.sizeLimited ? '適用' : '未適用'})`
          );
          
          // UIの表示用にメッセージを更新
          setMessages(limitedMessages);
          
          // 制限情報をrefに保存
          limitInfoRef.current = {
            limitApplied: true,
            limitInfo
          };
          
          // 制限が適用されたことを状態に記録
          // 無限ループを防ぐため、関数形式で前の状態を参照
          setStorageInfo(prev => ({
            ...prev,
            limitApplied: true,
            limitInfo
          }));
        }
        
        // ローカルストレージに保存
        setStoredMessages(limitedMessages);
        
        // 前回のメッセージを更新
        previousMessagesRef.current = [...limitedMessages];
        
        // 保存後にストレージ情報を再取得
        // setTimeout を使用せずに直接呼び出す
        updateStorageInfo();
      }
    }
  }, [messages, setStoredMessages, maxStoredMessages, maxStorageSizeBytes, updateStorageInfo]);

  /**
   * モデルを変更する
   * @param {string} model 新しいモデル名
   */
  const changeModel = useCallback((model) => {
    if (Object.values(CHAT_MODELS).includes(model)) {
      setSelectedModel(model);
    }
  }, []);

  /**
   * 会話履歴をクリアする
   */
  const clearConversation = useCallback(() => {
    console.log('[ChatConversation] 会話履歴をクリアします');
    setMessages([]);
    previousMessagesRef.current = [];
    removeStoredMessages();
    
    // 制限情報をリセット
    limitInfoRef.current = {
      limitApplied: false,
      limitInfo: null
    };
    
    // 制限適用状態もリセット
    setStorageInfo(prev => ({
      ...prev,
      limitApplied: false,
      limitInfo: null
    }));
    
    // ストレージ情報を更新
    updateStorageInfo();
  }, [removeStoredMessages, updateStorageInfo]);

  /**
   * メッセージオブジェクトを作成する
   * @param {string} role メッセージの役割（'user'または'assistant'）
   * @param {string} content メッセージの内容
   * @param {Object} additionalProps 追加のプロパティ
   * @returns {Object} メッセージオブジェクト
   */
  const createMessageObject = useCallback((role, content, additionalProps = {}) => {
    const now = new Date();
    return {
      role,
      content,
      timestamp: now.toISOString(),
      formattedTime: formatDateTime(now),
      ...additionalProps
    };
  }, []);

  /**
   * AIにメッセージを送信する
   * @param {string} content ユーザーのメッセージ内容
   * @returns {Promise<Object>} 応答メッセージ
   */
  const sendMessage = useCallback(async (content) => {
    try {
      // APIキーのチェック
      if (!currentApiKey) {
        throw new Error('APIキーが設定されていません。APIキー設定欄でAPIキーを設定してください。');
      }

      // ユーザーメッセージを追加
      const userMessage = createMessageObject('user', content);
      const updatedMessages = [...messages, userMessage];
      setMessages(updatedMessages);
      setIsLoading(true);

      // API送信用のメッセージを準備（メタデータを除いたroleとcontentのみ）
      const apiMessagesRaw = updatedMessages.map(({ role, content }) => ({ role, content }));
      
      // トークンとコンテキストウィンドウの制限に基づいてメッセージをフィルタリング
      const filteredApiMessages = filterMessagesForTokenLimit(
        apiMessagesRaw, 
        maxTokens, 
        contextWindowSize
      );
      
      // トークン数を概算
      const tokensEstimate = estimateMessagesTokens(filteredApiMessages);
      console.log(`メッセージをフィルタリングしました: ${apiMessagesRaw.length}件中${filteredApiMessages.length}件を送信、推定トークン数: ${tokensEstimate}`);

      // APIサービスを使ってサーバーAPIを呼び出す
      const response = await sendChatMessage(filteredApiMessages, selectedModel, currentApiKey);

      // AIの応答を追加
      const assistantMessage = createMessageObject('assistant', response.message.content, {
        model: selectedModel,
        tokensUsed: tokensEstimate
      });
      
      // 最新の会話履歴を更新
      setMessages([...updatedMessages, assistantMessage]);
      return assistantMessage;
    } catch (error) {
      console.error('チャットエラー:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [messages, selectedModel, contextWindowSize, maxTokens, currentApiKey, createMessageObject]);

  return {
    messages,
    isLoading,
    selectedModel,
    availableModels: CHAT_MODELS,
    estimatedTokens,
    hasApiKey,
    storageInfo,
    sendMessage,
    setApiKey,
    changeModel,
    clearConversation,
  };
}