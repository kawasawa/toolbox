// Generated by GitHub Copilot
'use client';

import { useState, useRef, useEffect } from 'react';

/**
 * 画像比較スライダー機能を提供するカスタムフック
 * @returns {Object} スライダー操作に関する状態と関数
 */
export function useComparisonSlider() {
  // 状態変数
  const [compareMode, setCompareMode] = useState('tab');   // 'tab' または 'slider'
  const [activeTab, setActiveTab] = useState('original');  // 'original' または 'processed'
  const [sliderPosition, setSliderPosition] = useState(50); // スライダーの位置（%）
  
  // 参照
  const sliderContainerRef = useRef(null);
  const sliderHandleRef = useRef(null);
  
  // 処理後の画像ができた時にタブを自動的に切り替え
  const handleProcessedImageChange = (processedImage) => {
    if (processedImage) {
      setActiveTab('processed');
    }
  };

  // スライダーのドラッグ操作を設定
  useEffect(() => {
    // スライダーモードでない場合はイベントリスナーを設定しない
    if (compareMode !== 'slider') return;
    
    if (!sliderContainerRef.current || !sliderHandleRef.current) return;
    
    const container = sliderContainerRef.current;
    const handle = sliderHandleRef.current;
    
    const onMouseDown = (startEvent) => {
      startEvent.preventDefault();
      
      // ドラッグ開始位置からの相対移動を計算するための関数
      const onMouseMove = (moveEvent) => {
        // コンテナの幅に対する相対位置を計算
        const containerRect = container.getBoundingClientRect();
        const newPosition = ((moveEvent.clientX - containerRect.left) / containerRect.width) * 100;
        
        // 0〜100%の範囲に制限
        const clampedPosition = Math.max(0, Math.min(100, newPosition));
        setSliderPosition(clampedPosition);
      };
      
      // マウスボタンを離したらイベントリスナーを削除
      const onMouseUp = () => {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
      
      // ドラッグイベントのリスナーを設定
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    };
    
    // タッチデバイス用のイベントハンドラ
    const onTouchStart = (startEvent) => {
      startEvent.preventDefault();
      
      const onTouchMove = (moveEvent) => {
        const containerRect = container.getBoundingClientRect();
        const newPosition = ((moveEvent.touches[0].clientX - containerRect.left) / containerRect.width) * 100;
        
        const clampedPosition = Math.max(0, Math.min(100, newPosition));
        setSliderPosition(clampedPosition);
      };
      
      const onTouchEnd = () => {
        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);
      };
      
      document.addEventListener('touchmove', onTouchMove);
      document.addEventListener('touchend', onTouchEnd);
    };
    
    // マウスとタッチのイベントリスナーを設定
    handle.addEventListener('mousedown', onMouseDown);
    handle.addEventListener('touchstart', onTouchStart);
    
    // クリーンアップ関数
    return () => {
      handle.removeEventListener('mousedown', onMouseDown);
      handle.removeEventListener('touchstart', onTouchStart);
    };
  }, [compareMode]); // compareMode が変更されたときだけ再設定

  return {
    // 状態
    compareMode,
    activeTab,
    sliderPosition,
    sliderContainerRef,
    sliderHandleRef,

    // 処理関数
    setCompareMode,
    setActiveTab,
    setSliderPosition,
    handleProcessedImageChange
  };
}